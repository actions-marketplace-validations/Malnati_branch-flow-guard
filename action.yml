# Malnati/branch-flow-guard@v1.1.0
name: "Branch Flow Guard Pro"
description: "Valida o fluxo de branches e retorna um JSON preenchido baseado no template local."
author: "Ricardo Malnati"

branding:
  icon: "git-merge"
  color: "purple"

inputs:
  token:
    description: "GitHub token"
    required: true
  production_branches:
    description: "NÃ­vel 1 (ProduÃ§Ã£o)"
    default: "main,master,prod,production"
  staging_branches:
    description: "NÃ­vel 2 (Staging)"
    default: "staging,stage,homol,release"
  development_branches:
    description: "NÃ­vel 3 (Development)"
    default: "dev,develop,development"
  output_file:
    description: "Caminho para salvar o JSON gerado (opcional)"
    default: "flow-compliance.json"

outputs:
  result:
    description: "O conteÃºdo JSON preenchido (string)"
    value: ${{ steps.render_json.outputs.json_content }}
  allowed:
    description: "Boolean: Flow is allowed"
    value: ${{ steps.analyze.outputs.allowed }}

runs:
  using: "composite"
  steps:
    # ------------------------------------------------------------------
    # STEP 0: DIAGNÃ“STICO DE INPUTS (Log Rico)
    # ------------------------------------------------------------------
    - id: debug_inputs
      shell: bash
      env:
        PROD_LIST: ${{ inputs.production_branches }}
        STAGE_LIST: ${{ inputs.staging_branches }}
        DEV_LIST: ${{ inputs.development_branches }}
        OUT_FILE: ${{ inputs.output_file }}
        HAS_TOKEN: ${{ inputs.token }}
      run: |
        echo "::group::ðŸ” Step 0: Governance Rules Configuration"
        echo "---------------------------------------------------------------"
        echo "ðŸ›¡ï¸  Branch Flow Definitions"
        echo "---------------------------------------------------------------"
        
        echo "1ï¸âƒ£  Production (Level 1):"
        echo "    Branches: [$PROD_LIST]"
        echo "    ðŸ‘‰ Regra: SÃ³ aceita merges vindos de Level 2 (Staging)."
        echo ""
        
        echo "2ï¸âƒ£  Staging (Level 2):"
        echo "    Branches: [$STAGE_LIST]"
        echo "    ðŸ‘‰ Regra: SÃ³ aceita merges vindos de Level 3 (Development)."
        echo ""
        
        echo "3ï¸âƒ£  Development (Level 3):"
        echo "    Branches: [$DEV_LIST]"
        echo "    ðŸ‘‰ Regra: Origem livre (Features, Hotfixes, etc)."
        echo "---------------------------------------------------------------"
        
        echo "ðŸ“‚ Configuration:"
        echo "   - Output JSON Path: $OUT_FILE"
        if [ -n "$HAS_TOKEN" ]; then
           echo "   - Token: PROVIDED (Masked)"
        else
           echo "   - Token: âŒ MISSING (Action will fail)"
        fi
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 0.5: VERIFICAÃ‡ÃƒO DE PERMISSÃ•ES
    # ------------------------------------------------------------------
    - id: debug_perms
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
        PR_NUM: ${{ github.event.pull_request.number }}
      run: |
        echo "::group::ðŸ” Step 0.5: Access & Connectivity Check"
        
        # Teste de conectividade simples com a API de arquivos da PR
        # Isso valida se o token tem permissÃ£o de leitura (contents: read)
        URL="https://api.github.com/repos/$REPO/pulls/$PR_NUM/files"
        
        echo "ðŸ“¡ Testing API Access (Read PR Files)..."
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN" "$URL")
        
        if [ "$HTTP_CODE" == "200" ]; then
           echo "   âœ… Status 200 OK - Acesso aos arquivos confirmado."
        else
           echo "   âš ï¸ Status $HTTP_CODE - Falha ao acessar arquivos da PR."
           echo "      Verifique se o token tem a permissÃ£o 'contents: read'."
        fi
        
        echo ""
        echo "ðŸ“‹ REQUIRED PERMISSIONS:"
        echo "   1. contents: read  (ObrigatÃ³rio para detectar mudanÃ§as de cÃ³digo)"
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 1: DETECTAR MUDANÃ‡AS DE CÃ“DIGO
    # ------------------------------------------------------------------
    - id: check_files
      shell: bash
      env:
        PR_NUM: ${{ github.event.pull_request.number }}
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
      run: |
        set -euo pipefail
        # Para este exemplo simplificado, assumimos true.
        # Em produÃ§Ã£o, aqui iria o curl para listar arquivos e grep nas extensÃµes.
        echo "has_code=true" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 2: ANALISAR E PREENCHER TEMPLATE
    # ------------------------------------------------------------------
    - id: analyze
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}
        PR_NUM: ${{ github.event.pull_request.number }}
        REPO: ${{ github.repository }}
        HEAD_REF: ${{ github.event.pull_request.head.ref }}
        BASE_REF: ${{ github.event.pull_request.base.ref }}
        PROD_LIST: ${{ inputs.production_branches }}
        STAGE_LIST: ${{ inputs.staging_branches }}
        DEV_LIST: ${{ inputs.development_branches }}
        HAS_CODE: ${{ steps.check_files.outputs.has_code }}
      run: |
        set -euo pipefail

        get_branch_type() {
          local branch=$1
          if echo "$PROD_LIST" | tr -d ' ' | tr ',' '\n' | grep -F -x -q "$branch"; then echo "production";
          elif echo "$STAGE_LIST" | tr -d ' ' | tr ',' '\n' | grep -F -x -q "$branch"; then echo "staging";
          elif echo "$DEV_LIST" | tr -d ' ' | tr ',' '\n' | grep -F -x -q "$branch"; then echo "development";
          else echo "other"; fi
        }

        HEAD_TYPE=$(get_branch_type "$HEAD_REF")
        BASE_TYPE=$(get_branch_type "$BASE_REF")

        ALLOWED="true"
        MSG="âœ… Fluxo autorizado."
        CODE="NONE"
        COLOR="#3fb950" # Green

        if [ "$BASE_TYPE" == "production" ] && [ "$HEAD_TYPE" != "staging" ]; then
            ALLOWED="false"
            MSG="ðŸš« **ProduÃ§Ã£o** requer origem em **Staging**."
            CODE="PROD_VIOLATION"
            COLOR="#d73a49" # Red
        elif [ "$BASE_TYPE" == "staging" ] && [ "$HEAD_TYPE" != "development" ]; then
            ALLOWED="false"
            MSG="ðŸš« **Staging** requer origem em **Development**."
            CODE="STAGE_VIOLATION"
            COLOR="#d73a49" # Red
        fi

        echo "allowed=$ALLOWED" >> "$GITHUB_OUTPUT"

        TEMPLATE_PATH="$GITHUB_ACTION_PATH/branch-flow-guard.json"
        
        if [ ! -f "$TEMPLATE_PATH" ]; then
          echo "::error::Template JSON nÃ£o encontrado em $TEMPLATE_PATH"
          exit 1
        fi
        
        JSON_CONTENT=$(cat "$TEMPLATE_PATH")
        TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        # SubstituiÃ§Ãµes
        JSON_CONTENT=${JSON_CONTENT//%TIMESTAMP%/$TIMESTAMP}
        JSON_CONTENT=${JSON_CONTENT//%ALLOWED%/$ALLOWED}
        JSON_CONTENT=${JSON_CONTENT//%HAS_CODE%/$HAS_CODE}
        JSON_CONTENT=${JSON_CONTENT//%VIOLATION_CODE%/$CODE}
        JSON_CONTENT=${JSON_CONTENT//%REPO%/$REPO}
        JSON_CONTENT=${JSON_CONTENT//%PR_NUM%/$PR_NUM}
        JSON_CONTENT=${JSON_CONTENT//%HEAD_REF%/$HEAD_REF}
        JSON_CONTENT=${JSON_CONTENT//%BASE_REF%/$BASE_REF}
        JSON_CONTENT=${JSON_CONTENT//%HEAD_TYPE%/$HEAD_TYPE}
        JSON_CONTENT=${JSON_CONTENT//%BASE_TYPE%/$BASE_TYPE}
        JSON_CONTENT=${JSON_CONTENT//%MESSAGE_MD%/$MSG}
        JSON_CONTENT=${JSON_CONTENT//%COLOR_HEX%/$COLOR}

        echo "$JSON_CONTENT" > /tmp/rendered_flow.json

    # ------------------------------------------------------------------
    # STEP 3: GERAR OUTPUT
    # ------------------------------------------------------------------
    - id: render_json
      shell: bash
      env:
        OUTPUT_FILE: ${{ inputs.output_file }}
      run: |
        CONTENT=$(cat /tmp/rendered_flow.json)
        
        if [ -n "$OUTPUT_FILE" ]; then
           cp /tmp/rendered_flow.json "./$OUTPUT_FILE"
           echo "JSON salvo em: ./$OUTPUT_FILE"
        fi

        {
          echo "json_content<<EOF"
          echo "$CONTENT"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"
