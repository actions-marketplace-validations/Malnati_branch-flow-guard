# Malnati/branch-flow-guard@v1.2.1
name: "Branch Flow Guard Pro"
description: "Valida o fluxo de branches e retorna um JSON preenchido com orientaÃ§Ãµes dinÃ¢micas."
author: "Ricardo Malnati"

branding:
  icon: "git-merge"
  color: "purple"

inputs:
  token:
    description: "GitHub token"
    required: true
  production_branches:
    description: "NÃ­vel 1 (ProduÃ§Ã£o)"
    default: "main,master,prod,production"
  staging_branches:
    description: "NÃ­vel 2 (Staging)"
    default: "staging,stage,homol,release"
  development_branches:
    description: "NÃ­vel 3 (Development)"
    default: "dev,develop,development"
  output_file:
    description: "Caminho para salvar o JSON gerado (opcional)"
    default: "flow-compliance.json"

outputs:
  result:
    description: "O conteÃºdo JSON preenchido (string)"
    value: ${{ steps.render_json.outputs.json_content }}
  allowed:
    description: "Boolean: Flow is allowed"
    value: ${{ steps.analyze.outputs.allowed }}

runs:
  using: "composite"
  steps:
    # ------------------------------------------------------------------
    # STEP 0: DIAGNÃ“STICO E CONFIGURAÃ‡ÃƒO (Melhorado)
    # ------------------------------------------------------------------
    - id: debug_inputs
      shell: bash
      env:
        PROD_LIST: ${{ inputs.production_branches }}
        STAGE_LIST: ${{ inputs.staging_branches }}
        DEV_LIST: ${{ inputs.development_branches }}
        OUT_FILE: ${{ inputs.output_file }}
        HAS_TOKEN: ${{ inputs.token }}
      run: |
        echo "::group::ðŸ” Step 0: Governance Rules Configuration"
        echo "---------------------------------------------------------------"
        echo "ðŸ›¡ï¸  Branch Flow Definitions (Active Rules)"
        echo "---------------------------------------------------------------"
        
        echo "1ï¸âƒ£  Production (Level 1):"
        echo "    Branches: [$PROD_LIST]"
        echo "    ðŸ‘‰ Aceita apenas origem: Level 2 (Staging)"
        echo ""
        
        echo "2ï¸âƒ£  Staging (Level 2):"
        echo "    Branches: [$STAGE_LIST]"
        echo "    ðŸ‘‰ Aceita apenas origem: Level 3 (Development)"
        echo ""
        
        echo "3ï¸âƒ£  Development (Level 3):"
        echo "    Branches: [$DEV_LIST]"
        echo "    ðŸ‘‰ Aceita origem livre (Features, Hotfixes, etc)"
        echo "---------------------------------------------------------------"
        
        # MENSAGEM EDUCATIVA PARA O DESENVOLVEDOR
        echo "ðŸ’¡ NOTA DE CONFIGURAÃ‡ÃƒO:"
        echo "   As regras acima sÃ£o definidas pelos inputs desta Action."
        echo "   VocÃª pode alterar as branches elegÃ­veis ajustando os parÃ¢metros:"
        echo "   - production_branches"
        echo "   - staging_branches"
        echo "   - development_branches"
        echo "   No arquivo do seu workflow."
        echo "---------------------------------------------------------------"
        
        echo "ðŸ“‚ System:"
        echo "   - Output Path: $OUT_FILE"
        if [ -n "$HAS_TOKEN" ]; then
           echo "   - Token: PROVIDED (Masked)"
        else
           echo "   - Token: âŒ MISSING"
        fi
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 0.5: PERMISSÃ•ES
    # ------------------------------------------------------------------
    - id: debug_perms
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
        PR_NUM: ${{ github.event.pull_request.number }}
      run: |
        echo "::group::ðŸ” Step 0.5: Access & Connectivity Check"
        URL="https://api.github.com/repos/$REPO/pulls/$PR_NUM/files"
        echo "ðŸ“¡ Testing API Access..."
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN" "$URL")
        
        if [ "$HTTP_CODE" == "200" ]; then
           echo "   âœ… Status 200 OK - Access granted."
        else
           echo "   âš ï¸ Status $HTTP_CODE - Failed to access PR files."
           echo "      Verify 'contents: read' permission."
        fi
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 1: DETECTAR CÃ“DIGO
    # ------------------------------------------------------------------
    - id: check_files
      shell: bash
      env:
        PR_NUM: ${{ github.event.pull_request.number }}
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
      run: |
        set -euo pipefail
        # Simplificado para o exemplo
        echo "has_code=true" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 2: ANALISAR E GERAR MENSAGENS DINÃ‚MICAS
    # ------------------------------------------------------------------
    - id: analyze
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}
        PR_NUM: ${{ github.event.pull_request.number }}
        REPO: ${{ github.repository }}
        HEAD_REF: ${{ github.event.pull_request.head.ref }}
        BASE_REF: ${{ github.event.pull_request.base.ref }}
        # Inputs limpos
        PROD_LIST: ${{ inputs.production_branches }}
        STAGE_LIST: ${{ inputs.staging_branches }}
        DEV_LIST: ${{ inputs.development_branches }}
        HAS_CODE: ${{ steps.check_files.outputs.has_code }}
      run: |
        set -euo pipefail

        get_branch_type() {
          local branch=$1
          if echo "$PROD_LIST" | tr -d ' ' | tr ',' '\n' | grep -F -x -q "$branch"; then echo "production";
          elif echo "$STAGE_LIST" | tr -d ' ' | tr ',' '\n' | grep -F -x -q "$branch"; then echo "staging";
          elif echo "$DEV_LIST" | tr -d ' ' | tr ',' '\n' | grep -F -x -q "$branch"; then echo "development";
          else echo "other"; fi
        }

        HEAD_TYPE=$(get_branch_type "$HEAD_REF")
        BASE_TYPE=$(get_branch_type "$BASE_REF")

        ALLOWED="true"
        MSG="âœ… **Autorizado:** Fluxo correto de branches."
        GUIDANCE="Pode prosseguir com o Code Review."
        CODE="NONE"
        COLOR="#3fb950"

        # LÃ³gica de Bloqueio + OrientaÃ§Ã£o DinÃ¢mica
        if [ "$BASE_TYPE" == "production" ] && [ "$HEAD_TYPE" != "staging" ]; then
            ALLOWED="false"
            MSG="ðŸš« **ProduÃ§Ã£o** ($BASE_REF) requer origem em **Staging**."
            CODE="PROD_VIOLATION"
            COLOR="#d73a49"
            
            # FormataÃ§Ã£o bonita da lista
            CLEAN_LIST=$(echo "$STAGE_LIST" | sed 's/,/, /g')
            GUIDANCE="Para mergear em \`$BASE_REF\`, a branch de origem deve ser uma destas: **[$CLEAN_LIST]**."
            
        elif [ "$BASE_TYPE" == "staging" ] && [ "$HEAD_TYPE" != "development" ]; then
            ALLOWED="false"
            MSG="ðŸš« **Staging** ($BASE_REF) requer origem em **Development**."
            CODE="STAGE_VIOLATION"
            COLOR="#d73a49"
            
            CLEAN_LIST=$(echo "$DEV_LIST" | sed 's/,/, /g')
            GUIDANCE="Para mergear em \`$BASE_REF\`, a branch de origem deve ser uma destas: **[$CLEAN_LIST]**."
        fi

        echo "allowed=$ALLOWED" >> "$GITHUB_OUTPUT"

        TEMPLATE_PATH="$GITHUB_ACTION_PATH/message.json"
        if [ ! -f "$TEMPLATE_PATH" ]; then
          echo "::error::Template JSON missing at $TEMPLATE_PATH"
          exit 1
        fi
        
        JSON_CONTENT=$(cat "$TEMPLATE_PATH")
        TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        # SubstituiÃ§Ãµes (incluindo o novo %GUIDANCE%)
        JSON_CONTENT=${JSON_CONTENT//%TIMESTAMP%/$TIMESTAMP}
        JSON_CONTENT=${JSON_CONTENT//%ALLOWED%/$ALLOWED}
        JSON_CONTENT=${JSON_CONTENT//%HAS_CODE%/$HAS_CODE}
        JSON_CONTENT=${JSON_CONTENT//%VIOLATION_CODE%/$CODE}
        JSON_CONTENT=${JSON_CONTENT//%REPO%/$REPO}
        JSON_CONTENT=${JSON_CONTENT//%PR_NUM%/$PR_NUM}
        JSON_CONTENT=${JSON_CONTENT//%HEAD_REF%/$HEAD_REF}
        JSON_CONTENT=${JSON_CONTENT//%BASE_REF%/$BASE_REF}
        JSON_CONTENT=${JSON_CONTENT//%HEAD_TYPE%/$HEAD_TYPE}
        JSON_CONTENT=${JSON_CONTENT//%BASE_TYPE%/$BASE_TYPE}
        JSON_CONTENT=${JSON_CONTENT//%MESSAGE_MD%/$MSG}
        JSON_CONTENT=${JSON_CONTENT//%GUIDANCE%/$GUIDANCE}
        JSON_CONTENT=${JSON_CONTENT//%COLOR_HEX%/$COLOR}

        echo "$JSON_CONTENT" > /tmp/rendered_flow.json

    # ------------------------------------------------------------------
    # STEP 3: OUTPUT
    # ------------------------------------------------------------------
    - id: render_json
      shell: bash
      env:
        OUTPUT_FILE: ${{ inputs.output_file }}
      run: |
        CONTENT=$(cat /tmp/rendered_flow.json)
        if [ -n "$OUTPUT_FILE" ]; then
           cp /tmp/rendered_flow.json "./$OUTPUT_FILE"
           echo "JSON salvo em: ./$OUTPUT_FILE"
        fi
        {
          echo "json_content<<EOF"
          echo "$CONTENT"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"
