# action v1.0.0
name: "Branch Flow Guard Pro"
description: "Valida o fluxo de branches e retorna um JSON preenchido baseado no template local."
author: "Ricardo Malnati"

branding:
  icon: "git-merge"
  color: "purple"

inputs:
  token:
    description: "GitHub token"
    required: true
  production_branches:
    description: "N√≠vel 1 (Produ√ß√£o)"
    default: "main,master,prod,production"
  staging_branches:
    description: "N√≠vel 2 (Staging)"
    default: "staging,stage,homol,release"
  development_branches:
    description: "N√≠vel 3 (Development)"
    default: "dev,develop,development"
  output_file:
    description: "Caminho para salvar o JSON gerado (opcional)"
    default: "flow-compliance.json"

outputs:
  # Output principal: O JSON completo como string
  result:
    description: "O conte√∫do JSON preenchido (string)"
    value: ${{ steps.render_json.outputs.json_content }}
  
  # Outputs auxiliares (atalhos)
  allowed:
    description: "Boolean: Flow is allowed"
    value: ${{ steps.analyze.outputs.allowed }}

runs:
  using: "composite"
  steps:
    # ... (Step de check_files anterior permanece igual) ...
    - id: check_files
      shell: bash
      env:
        PR_NUM: ${{ github.event.pull_request.number }}
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
      run: |
        # L√≥gica resumida de detec√ß√£o de c√≥digo
        # Para o exemplo, assumimos true
        echo "has_code=true" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP: ANALISAR E PREENCHER TEMPLATE
    # ------------------------------------------------------------------
    - id: analyze
      shell: bash
      env:
        # Contextos
        GITHUB_ACTION_PATH: ${{ github.action_path }} # Onde est√° o .json
        PR_NUM: ${{ github.event.pull_request.number }}
        REPO: ${{ github.repository }}
        HEAD_REF: ${{ github.event.pull_request.head.ref }}
        BASE_REF: ${{ github.event.pull_request.base.ref }}
        # Inputs
        PROD_LIST: ${{ inputs.production_branches }}
        STAGE_LIST: ${{ inputs.staging_branches }}
        DEV_LIST: ${{ inputs.development_branches }}
        HAS_CODE: ${{ steps.check_files.outputs.has_code }}
      run: |
        set -euo pipefail

        # 1. Classifica√ß√£o de Branches (Mesma l√≥gica anterior)
        get_branch_type() {
          local branch=$1
          if echo "$PROD_LIST" | tr -d ' ' | tr ',' '\n' | grep -F -x -q "$branch"; then echo "production";
          elif echo "$STAGE_LIST" | tr -d ' ' | tr ',' '\n' | grep -F -x -q "$branch"; then echo "staging";
          elif echo "$DEV_LIST" | tr -d ' ' | tr ',' '\n' | grep -F -x -q "$branch"; then echo "development";
          else echo "other"; fi
        }

        HEAD_TYPE=$(get_branch_type "$HEAD_REF")
        BASE_TYPE=$(get_branch_type "$BASE_REF")

        # 2. Defini√ß√£o de Regras
        ALLOWED="true"
        MSG="‚úÖ Fluxo autorizado."
        CODE="NONE"
        COLOR="#3fb950" # Green

        if [ "$BASE_TYPE" == "production" ] && [ "$HEAD_TYPE" != "staging" ]; then
            ALLOWED="false"
            MSG="üö´ **Produ√ß√£o** requer origem em **Staging**."
            CODE="PROD_VIOLATION"
            COLOR="#d73a49" # Red
        elif [ "$BASE_TYPE" == "staging" ] && [ "$HEAD_TYPE" != "development" ]; then
            ALLOWED="false"
            MSG="üö´ **Staging** requer origem em **Development**."
            CODE="STAGE_VIOLATION"
            COLOR="#d73a49" # Red
        fi

        # Exporta vari√°vel simples para outputs
        echo "allowed=$ALLOWED" >> "$GITHUB_OUTPUT"

        # 3. Ler o Template Local
        # Importante: Em composite actions, arquivos est√£o em $GITHUB_ACTION_PATH
        TEMPLATE_PATH="$GITHUB_ACTION_PATH/branch-flow-guard.json"
        
        if [ ! -f "$TEMPLATE_PATH" ]; then
          echo "::error::Template JSON n√£o encontrado em $TEMPLATE_PATH"
          exit 1
        fi
        
        # Carrega conte√∫do
        JSON_CONTENT=$(cat "$TEMPLATE_PATH")

        # 4. Substitui√ß√£o (Search & Replace)
        # Usamos sed. Importante escapar barras na MSG se houver.
        
        TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        # Substitui√ß√µes
        # Dica: Usar separador diferente no sed (ex: |) evita conflito com barras de URL/Path
        JSON_CONTENT=${JSON_CONTENT//%TIMESTAMP%/$TIMESTAMP}
        JSON_CONTENT=${JSON_CONTENT//%ALLOWED%/$ALLOWED}
        JSON_CONTENT=${JSON_CONTENT//%HAS_CODE%/$HAS_CODE}
        JSON_CONTENT=${JSON_CONTENT//%VIOLATION_CODE%/$CODE}
        JSON_CONTENT=${JSON_CONTENT//%REPO%/$REPO}
        JSON_CONTENT=${JSON_CONTENT//%PR_NUM%/$PR_NUM}
        JSON_CONTENT=${JSON_CONTENT//%HEAD_REF%/$HEAD_REF}
        JSON_CONTENT=${JSON_CONTENT//%BASE_REF%/$BASE_REF}
        JSON_CONTENT=${JSON_CONTENT//%HEAD_TYPE%/$HEAD_TYPE}
        JSON_CONTENT=${JSON_CONTENT//%BASE_TYPE%/$BASE_TYPE}
        JSON_CONTENT=${JSON_CONTENT//%MESSAGE_MD%/$MSG}
        JSON_CONTENT=${JSON_CONTENT//%COLOR_HEX%/$COLOR}

        # 5. Salvar em arquivo tempor√°rio para persist√™ncia
        echo "$JSON_CONTENT" > /tmp/rendered_flow.json

    - id: render_json
      shell: bash
      env:
        OUTPUT_FILE: ${{ inputs.output_file }}
      run: |
        # Recupera o JSON da etapa anterior
        CONTENT=$(cat /tmp/rendered_flow.json)
        
        # Op√ß√£o A: Salvar no arquivo f√≠sico solicitado pelo usu√°rio (no workspace)
        if [ -n "$OUTPUT_FILE" ]; then
           cp /tmp/rendered_flow.json "./$OUTPUT_FILE"
           echo "JSON salvo em: ./$OUTPUT_FILE"
        fi

        # Op√ß√£o B: Jogar no Output do GitHub (Removendo quebras de linha para n√£o quebrar o GITHUB_OUTPUT)
        # O truque do EOF √© melhor para JSONs complexos
        {
          echo "json_content<<EOF"
          echo "$CONTENT"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"
